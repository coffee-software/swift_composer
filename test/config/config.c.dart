// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'config.dart';

// **************************************************************************
// SwiftGenerator
// **************************************************************************

// **************************************************************************
// generated by swift_composer at 2021-08-21 15:23:07.126472
//loading config file /home/fsw/workspace/swift_composer/test/lib/module1.di.yaml
//loading config file /home/fsw/workspace/swift_composer/test/lib/module2.di.yaml
//loading config file /home/fsw/workspace/swift_composer/test/config/config.di.yaml
// **************************************************************************
// import package:swift_composer/swift_composer.dart
// import asset:swift_composer/test/lib/module1.dart as m1
// import asset:swift_composer/test/lib/module2.dart as m2
// **************************************************************************
//no interceptor for [AnnotatedWith]
// **************************************************************************
//no interceptor for [Pluggable]
// **************************************************************************
//no interceptor for [TypePlugin]
// **************************************************************************
//interceptor for [m1.Foo]
//type arguments[1]:
//type arguments[2]:
//can be singleton: TRUE
//parent: Object [@pragma pragma(String name, [Object? options])]
//parent: Pluggable []
//CONFIG
//config: m1.Foo {stringField: FooField, integerField: 124}
//config: m1.FooChild {stringField: FooChildField, doubleField: 0.55, booleanField: true}
//config: m1.FooChild2 {stringField: FooChild2Field, doubleField: 0.55, booleanField: true}
//config: m1.Bar {stringField: BarField}
//config: m1.BarChild {stringField: BarChildField}
//config: m2.Foo {stringField2: FooStringField2}
//config: VirtualTypeX {extends: m1.SimpleGeneric<m1.Foo>, stringField: FooStringField2}
//config: m1.Foo 1
//config: stringField FooField
//config: integerField 124
//TYPE PATH:
//   m1.Foo
class $m1_Foo extends m1.Foo implements Pluggable {
  $m1_Foo() {}
  T plugin<T>() {
    throw new Exception('no plugin for this type');
  }

  String get className => "m1.Foo";
  String get stringField => "FooField";
  int get integerField => 124;
}

// **************************************************************************
//interceptor for [m1.FooChild]
//type arguments[1]:
//type arguments[2]:
//can be singleton: TRUE
//parent: Foo [@bool get Compose]
//parent: Object [@pragma pragma(String name, [Object? options])]
//parent: Pluggable []
//CONFIG
//config: m1.Foo {stringField: FooField, integerField: 124}
//config: m1.FooChild {stringField: FooChildField, doubleField: 0.55, booleanField: true}
//config: m1.FooChild2 {stringField: FooChild2Field, doubleField: 0.55, booleanField: true}
//config: m1.Bar {stringField: BarField}
//config: m1.BarChild {stringField: BarChildField}
//config: m2.Foo {stringField2: FooStringField2}
//config: VirtualTypeX {extends: m1.SimpleGeneric<m1.Foo>, stringField: FooStringField2}
//config: m1.FooChild 1
//config: stringField FooChildField
//config: doubleField 0.55
//config: booleanField true
//config: m1.Foo 2
//config: integerField 124
//TYPE PATH:
//   m1.FooChild
//   m1.Foo
class $m1_FooChild extends m1.FooChild implements Pluggable {
  $m1_FooChild() {}
  T plugin<T>() {
    throw new Exception('no plugin for this type');
  }

  double get doubleField => 0.55;
  bool get booleanField => true;
  String get className => "m1.FooChild";
  String get stringField => "FooChildField";
  int get integerField => 124;
}

// **************************************************************************
//interceptor for [m1.FooChild2]
//type arguments[1]:
//type arguments[2]:
//can be singleton: FALSE
//parent: Foo [@bool get Compose]
//parent: Object [@pragma pragma(String name, [Object? options])]
//parent: Pluggable []
//CONFIG
//config: m1.Foo {stringField: FooField, integerField: 124}
//config: m1.FooChild {stringField: FooChildField, doubleField: 0.55, booleanField: true}
//config: m1.FooChild2 {stringField: FooChild2Field, doubleField: 0.55, booleanField: true}
//config: m1.Bar {stringField: BarField}
//config: m1.BarChild {stringField: BarChildField}
//config: m2.Foo {stringField2: FooStringField2}
//config: VirtualTypeX {extends: m1.SimpleGeneric<m1.Foo>, stringField: FooStringField2}
//config: m1.FooChild2 1
//config: stringField FooChild2Field
//config: doubleField 0.55
//config: booleanField true
//config: m1.Foo 2
//config: integerField 124
//TYPE PATH:
//   m1.FooChild2
//   m1.Foo
class $m1_FooChild2 extends m1.FooChild2 implements Pluggable {
  $m1_FooChild2(requiredString) {
//String
    this.requiredString = requiredString;
  }
  T plugin<T>() {
    throw new Exception('no plugin for this type');
  }

  String get className => "m1.FooChild2";
  String get stringField => "FooChild2Field";
  int get integerField => 124;
}

// **************************************************************************
//interceptor for [m1.Bar]
//type arguments[1]:
//type arguments[2]:
//can be singleton: TRUE
//parent: Object [@pragma pragma(String name, [Object? options])]
//CONFIG
//config: m1.Foo {stringField: FooField, integerField: 124}
//config: m1.FooChild {stringField: FooChildField, doubleField: 0.55, booleanField: true}
//config: m1.FooChild2 {stringField: FooChild2Field, doubleField: 0.55, booleanField: true}
//config: m1.Bar {stringField: BarField}
//config: m1.BarChild {stringField: BarChildField}
//config: m2.Foo {stringField2: FooStringField2}
//config: VirtualTypeX {extends: m1.SimpleGeneric<m1.Foo>, stringField: FooStringField2}
//config: m1.Bar 1
//config: stringField BarField
//TYPE PATH:
//   m1.Bar
class $m1_Bar extends m1.Bar implements Pluggable {
  $m1_Bar() {}
  T plugin<T>() {
    throw new Exception('no plugin for this type');
  }

  String get stringField => "BarField";
  List<String> get classNames => [];
}

// **************************************************************************
//interceptor for [m1.BarChild]
//type arguments[1]:
//type arguments[2]:
//can be singleton: TRUE
//parent: Bar [@bool get Compose]
//parent: Object [@pragma pragma(String name, [Object? options])]
//CONFIG
//config: m1.Foo {stringField: FooField, integerField: 124}
//config: m1.FooChild {stringField: FooChildField, doubleField: 0.55, booleanField: true}
//config: m1.FooChild2 {stringField: FooChild2Field, doubleField: 0.55, booleanField: true}
//config: m1.Bar {stringField: BarField}
//config: m1.BarChild {stringField: BarChildField}
//config: m2.Foo {stringField2: FooStringField2}
//config: VirtualTypeX {extends: m1.SimpleGeneric<m1.Foo>, stringField: FooStringField2}
//config: m1.BarChild 1
//config: stringField BarChildField
//config: m1.Bar 2
//TYPE PATH:
//   m1.BarChild
//   m1.Bar
class $m1_BarChild extends m1.BarChild implements Pluggable {
  $m1_BarChild() {}
  T plugin<T>() {
    throw new Exception('no plugin for this type');
  }

  String get stringField => "BarChildField";
  List<String> get classNames => ['m1.BarChild'];
}

// **************************************************************************
//interceptor for [m1.SimpleGeneric]
//type arguments[1]:
//T[99166349] => T[99166349]
//type arguments[2]:
//can be singleton: TRUE
//parameter: T 99166349
//argument: T 99166349
//parent: Object [@pragma pragma(String name, [Object? options])]
//parent: Pluggable []
//CONFIG
//config: m1.Foo {stringField: FooField, integerField: 124}
//config: m1.FooChild {stringField: FooChildField, doubleField: 0.55, booleanField: true}
//config: m1.FooChild2 {stringField: FooChild2Field, doubleField: 0.55, booleanField: true}
//config: m1.Bar {stringField: BarField}
//config: m1.BarChild {stringField: BarChildField}
//config: m2.Foo {stringField2: FooStringField2}
//config: VirtualTypeX {extends: m1.SimpleGeneric<m1.Foo>, stringField: FooStringField2}
//NO ELEMENT!
//config: m1.SimpleGeneric<m1.T> 1
//TYPE PATH:
//NO ELEMENT!
//   m1.SimpleGeneric<m1.T>
class $m1_SimpleGeneric<T> extends m1.SimpleGeneric<T> implements Pluggable {
  $m1_SimpleGeneric() {}
  T plugin<T>() {
    throw new Exception('no plugin for this type');
  }
//NO ELEMENT!
}

// **************************************************************************
//interceptor for [m2.Foo]
//type arguments[1]:
//type arguments[2]:
//can be singleton: TRUE
//parent: Object [@pragma pragma(String name, [Object? options])]
//CONFIG
//config: m1.Foo {stringField: FooField, integerField: 124}
//config: m1.FooChild {stringField: FooChildField, doubleField: 0.55, booleanField: true}
//config: m1.FooChild2 {stringField: FooChild2Field, doubleField: 0.55, booleanField: true}
//config: m1.Bar {stringField: BarField}
//config: m1.BarChild {stringField: BarChildField}
//config: m2.Foo {stringField2: FooStringField2}
//config: VirtualTypeX {extends: m1.SimpleGeneric<m1.Foo>, stringField: FooStringField2}
//config: m2.Foo 1
//config: stringField2 FooStringField2
//TYPE PATH:
//   m2.Foo
class $m2_Foo extends m2.Foo implements Pluggable {
  $m2_Foo() {}
  T plugin<T>() {
    throw new Exception('no plugin for this type');
  }

  String get className => "m2.Foo";
  String get stringField2 => "FooStringField2";
}

// **************************************************************************
//interceptor for [m2.ComplexGeneric]
//type arguments[1]:
//A[365839863] => A[365839863]
//B[404026199] => B[404026199]
//type arguments[2]:
//can be singleton: TRUE
//parameter: A 365839863
//parameter: B 404026199
//argument: A 365839863
//argument: B 404026199
//parent: Object [@pragma pragma(String name, [Object? options])]
//CONFIG
//config: m1.Foo {stringField: FooField, integerField: 124}
//config: m1.FooChild {stringField: FooChildField, doubleField: 0.55, booleanField: true}
//config: m1.FooChild2 {stringField: FooChild2Field, doubleField: 0.55, booleanField: true}
//config: m1.Bar {stringField: BarField}
//config: m1.BarChild {stringField: BarChildField}
//config: m2.Foo {stringField2: FooStringField2}
//config: VirtualTypeX {extends: m1.SimpleGeneric<m1.Foo>, stringField: FooStringField2}
//NO ELEMENT!
//NO ELEMENT!
//config: m2.ComplexGeneric<m2.A,m2.B> 1
//TYPE PATH:
//NO ELEMENT!
//NO ELEMENT!
//   m2.ComplexGeneric<m2.A,m2.B>
class $m2_ComplexGeneric<A, B> extends m2.ComplexGeneric<A, B>
    implements Pluggable {
  $m2_ComplexGeneric() {}
  T plugin<T>() {
    throw new Exception('no plugin for this type');
  }
//NO ELEMENT!
}

// **************************************************************************
//interceptor for [m2.SuperComplexGeneric]
//type arguments[1]:
//A[365839863] => Foo[91930601]
//B[404026199] => A[520877666]
//A[520877666] => A[520877666]
//B[39484923] => B[39484923]
//type arguments[2]:
//can be singleton: TRUE
//parameter: A 520877666
//parameter: B 39484923
//argument: A 520877666
//argument: B 39484923
//parent: ComplexGeneric [@bool get Compose]
//parameter: A 365839863
//parameter: B 404026199
//argument: Foo 91930601
//argument: A 520877666
//parent: Object [@pragma pragma(String name, [Object? options])]
//CONFIG
//config: m1.Foo {stringField: FooField, integerField: 124}
//config: m1.FooChild {stringField: FooChildField, doubleField: 0.55, booleanField: true}
//config: m1.FooChild2 {stringField: FooChild2Field, doubleField: 0.55, booleanField: true}
//config: m1.Bar {stringField: BarField}
//config: m1.BarChild {stringField: BarChildField}
//config: m2.Foo {stringField2: FooStringField2}
//config: VirtualTypeX {extends: m1.SimpleGeneric<m1.Foo>, stringField: FooStringField2}
//NO ELEMENT!
//NO ELEMENT!
//NO ELEMENT!
//config: m2.SuperComplexGeneric<m2.A,m2.B> 1
//config: m2.ComplexGeneric<m2.Foo,m2.A> 2
//TYPE PATH:
//NO ELEMENT!
//NO ELEMENT!
//   m2.SuperComplexGeneric<m2.A,m2.B>
//NO ELEMENT!
//   m2.ComplexGeneric<m2.Foo,m2.A>
class $m2_SuperComplexGeneric<A, B> extends m2.SuperComplexGeneric<A, B>
    implements Pluggable {
  $m2_SuperComplexGeneric() {}
  T plugin<T>() {
    throw new Exception('no plugin for this type');
  }
//NO ELEMENT!
//NO ELEMENT!
}

// **************************************************************************
//interceptor for [Container]
//type arguments[1]:
//type arguments[2]:
//can be singleton: FALSE
//parent: Object [@pragma pragma(String name, [Object? options])]
//CONFIG
//config: m1.Foo {stringField: FooField, integerField: 124}
//config: m1.FooChild {stringField: FooChildField, doubleField: 0.55, booleanField: true}
//config: m1.FooChild2 {stringField: FooChild2Field, doubleField: 0.55, booleanField: true}
//config: m1.Bar {stringField: BarField}
//config: m1.BarChild {stringField: BarChildField}
//config: m2.Foo {stringField2: FooStringField2}
//config: VirtualTypeX {extends: m1.SimpleGeneric<m1.Foo>, stringField: FooStringField2}
//config: Container 1
//TYPE PATH:
//   Container
class $Container extends Container implements Pluggable {
  $Container(fooRequired, genericRequired) {
//Foo
//create
//candidate: AnnotatedWith
//element ok
//name not fit
//interceptor ok
//candidate: Pluggable
//element ok
//name not fit
//candidate: TypePlugin
//element ok
//name not fit
//candidate: m1.Foo
//element ok
//candidate: m1.FooChild
//element ok
//name not fit
//interceptor ok
//candidate: m1.FooChild2
//element ok
//name not fit
//interceptor ok
//candidate: m1.Bar
//element ok
//name not fit
//interceptor ok
//candidate: m1.BarChild
//element ok
//name not fit
//interceptor ok
//candidate: m1.SimpleGeneric
//element ok
//name not fit
//interceptor ok
//candidate: m2.Foo
//element ok
//name not fit
//interceptor ok
//candidate: m2.ComplexGeneric
//element ok
//name not fit
//interceptor ok
//candidate: m2.SuperComplexGeneric
//element ok
//name not fit
//interceptor ok
//candidate: Container
//element ok
//name not fit
//interceptor ok
//candidate: String
//element ok
//name not fit
//candidate: int
//element ok
//name not fit
//candidate: double
//element ok
//name not fit
//candidate: bool
//element ok
//name not fit
//interceptor ok
//candidate: List<String>
//element ok
//name not fit
//candidate: m1.T
//candidate: m1.SimpleGeneric<m1.T>
//element ok
//name not fit
//candidate: void
//candidate: m2.A
//candidate: m2.B
//candidate: m2.ComplexGeneric<m2.A,m2.B>
//element ok
//name not fit
//candidate: m2.SuperComplexGeneric<m2.A,m2.B>
//element ok
//name not fit
//candidate: m2.ComplexGeneric<m2.Foo,m2.A>
//element ok
//name not fit
    this.fooCreated = new $m1_Foo();
//SimpleGeneric<Foo>
//create
//candidate: AnnotatedWith
//element ok
//name not fit
//interceptor ok
//candidate: Pluggable
//element ok
//name not fit
//candidate: TypePlugin
//element ok
//name not fit
//candidate: m1.Foo
//element ok
//name not fit
//interceptor ok
//candidate: m1.FooChild
//element ok
//name not fit
//interceptor ok
//candidate: m1.FooChild2
//element ok
//name not fit
//interceptor ok
//candidate: m1.Bar
//element ok
//name not fit
//interceptor ok
//candidate: m1.BarChild
//element ok
//name not fit
//interceptor ok
//candidate: m1.SimpleGeneric
//element ok
//name not fit
//interceptor ok
//candidate: m2.Foo
//element ok
//name not fit
//interceptor ok
//candidate: m2.ComplexGeneric
//element ok
//name not fit
//interceptor ok
//candidate: m2.SuperComplexGeneric
//element ok
//name not fit
//interceptor ok
//candidate: Container
//element ok
//name not fit
//interceptor ok
//candidate: String
//element ok
//name not fit
//candidate: int
//element ok
//name not fit
//candidate: double
//element ok
//name not fit
//candidate: bool
//element ok
//name not fit
//interceptor ok
//candidate: List<String>
//element ok
//name not fit
//candidate: m1.T
//candidate: m1.SimpleGeneric<m1.T>
//element ok
//name not fit
//candidate: void
//candidate: m2.A
//candidate: m2.B
//candidate: m2.ComplexGeneric<m2.A,m2.B>
//element ok
//name not fit
//candidate: m2.SuperComplexGeneric<m2.A,m2.B>
//element ok
//name not fit
//candidate: m2.ComplexGeneric<m2.Foo,m2.A>
//element ok
//name not fit
//candidate: m1.SimpleGeneric<m1.Foo>
//element ok
    this.genericCreated = new $m1_SimpleGeneric_m1_Foo_();
//Foo
    this.fooRequired = fooRequired;
//SimpleGeneric<Foo>
    this.genericRequired = genericRequired;
  }
  T plugin<T>() {
    throw new Exception('no plugin for this type');
  }

//candidate: AnnotatedWith
//element ok
//name not fit
//interceptor ok
//candidate: Pluggable
//element ok
//name not fit
//candidate: TypePlugin
//element ok
//name not fit
//candidate: m1.Foo
//element ok
//candidate: m1.FooChild
//element ok
//name not fit
//interceptor ok
//candidate: m1.FooChild2
//element ok
//name not fit
//interceptor ok
//candidate: m1.Bar
//element ok
//name not fit
//interceptor ok
//candidate: m1.BarChild
//element ok
//name not fit
//interceptor ok
//candidate: m1.SimpleGeneric
//element ok
//name not fit
//interceptor ok
//candidate: m2.Foo
//element ok
//name not fit
//interceptor ok
//candidate: m2.ComplexGeneric
//element ok
//name not fit
//interceptor ok
//candidate: m2.SuperComplexGeneric
//element ok
//name not fit
//interceptor ok
//candidate: Container
//element ok
//name not fit
//interceptor ok
//candidate: String
//element ok
//name not fit
//candidate: int
//element ok
//name not fit
//candidate: double
//element ok
//name not fit
//candidate: bool
//element ok
//name not fit
//interceptor ok
//candidate: List<String>
//element ok
//name not fit
//candidate: m1.T
//candidate: m1.SimpleGeneric<m1.T>
//element ok
//name not fit
//candidate: void
//candidate: m2.A
//candidate: m2.B
//candidate: m2.ComplexGeneric<m2.A,m2.B>
//element ok
//name not fit
//candidate: m2.SuperComplexGeneric<m2.A,m2.B>
//element ok
//name not fit
//candidate: m2.ComplexGeneric<m2.Foo,m2.A>
//element ok
//name not fit
//candidate: m1.SimpleGeneric<m1.Foo>
//element ok
//name not fit
//interceptor ok
//candidate: m1.SimpleGeneric<m2.Foo>
//element ok
//name not fit
//interceptor ok
  m1.Foo get fooInjected => $om.m1_Foo;
//candidate: AnnotatedWith
//element ok
//name not fit
//interceptor ok
//candidate: Pluggable
//element ok
//name not fit
//candidate: TypePlugin
//element ok
//name not fit
//candidate: m1.Foo
//element ok
//name not fit
//interceptor ok
//candidate: m1.FooChild
//element ok
//name not fit
//interceptor ok
//candidate: m1.FooChild2
//element ok
//name not fit
//interceptor ok
//candidate: m1.Bar
//element ok
//name not fit
//interceptor ok
//candidate: m1.BarChild
//element ok
//name not fit
//interceptor ok
//candidate: m1.SimpleGeneric
//element ok
//name not fit
//interceptor ok
//candidate: m2.Foo
//element ok
//name not fit
//interceptor ok
//candidate: m2.ComplexGeneric
//element ok
//name not fit
//interceptor ok
//candidate: m2.SuperComplexGeneric
//element ok
//name not fit
//interceptor ok
//candidate: Container
//element ok
//name not fit
//interceptor ok
//candidate: String
//element ok
//name not fit
//candidate: int
//element ok
//name not fit
//candidate: double
//element ok
//name not fit
//candidate: bool
//element ok
//name not fit
//interceptor ok
//candidate: List<String>
//element ok
//name not fit
//candidate: m1.T
//candidate: m1.SimpleGeneric<m1.T>
//element ok
//name not fit
//candidate: void
//candidate: m2.A
//candidate: m2.B
//candidate: m2.ComplexGeneric<m2.A,m2.B>
//element ok
//name not fit
//candidate: m2.SuperComplexGeneric<m2.A,m2.B>
//element ok
//name not fit
//candidate: m2.ComplexGeneric<m2.Foo,m2.A>
//element ok
//name not fit
//candidate: m1.SimpleGeneric<m1.Foo>
//element ok
//candidate: m1.SimpleGeneric<m2.Foo>
//element ok
//name not fit
//interceptor ok
  m1.SimpleGeneric<m1.Foo> get genericInjected => $om.m1_SimpleGeneric_m1_Foo_;
}

// **************************************************************************
//no interceptor for [String]
// **************************************************************************
//no interceptor for [int]
// **************************************************************************
//no interceptor for [double]
// **************************************************************************
//no interceptor for [bool]
// **************************************************************************
//no interceptor for [List<String>]
// **************************************************************************
//no interceptor for [m1.T]
// **************************************************************************
//no interceptor for [m1.SimpleGeneric<m1.T>]
// **************************************************************************
//no interceptor for [void]
// **************************************************************************
//no interceptor for [m2.A]
// **************************************************************************
//no interceptor for [m2.B]
// **************************************************************************
//no interceptor for [m2.ComplexGeneric<m2.A,m2.B>]
// **************************************************************************
//no interceptor for [m2.SuperComplexGeneric<m2.A,m2.B>]
// **************************************************************************
//no interceptor for [m2.ComplexGeneric<m2.Foo,m2.A>]
// **************************************************************************
//interceptor for [m1.SimpleGeneric<m1.Foo>]
//type arguments[1]:
//T[99166349] => Foo[319114392]
//type arguments[2]:
//ENCLOSING: XXX
//Foo[309887332]
//can be singleton: TRUE
//parameter: T 99166349
//argument: T 99166349
//parent: Object [@pragma pragma(String name, [Object? options])]
//parent: Pluggable []
//CONFIG
//config: m1.Foo {stringField: FooField, integerField: 124}
//config: m1.FooChild {stringField: FooChildField, doubleField: 0.55, booleanField: true}
//config: m1.FooChild2 {stringField: FooChild2Field, doubleField: 0.55, booleanField: true}
//config: m1.Bar {stringField: BarField}
//config: m1.BarChild {stringField: BarChildField}
//config: m2.Foo {stringField2: FooStringField2}
//config: VirtualTypeX {extends: m1.SimpleGeneric<m1.Foo>, stringField: FooStringField2}
//config: m1.SimpleGeneric<m1.Foo> 1
//TYPE PATH:
//   m1.SimpleGeneric<m1.Foo>
//parametrized type
class $m1_SimpleGeneric_m1_Foo_ extends $m1_SimpleGeneric<$m1_Foo>
    implements Pluggable {
  $m1_SimpleGeneric() {}
  T plugin<T>() {
    throw new Exception('no plugin for this type');
  }
//NO ELEMENT!
}

// **************************************************************************
//interceptor for [m1.SimpleGeneric<m2.Foo>]
//type arguments[1]:
//T[99166349] => Foo[91930601]
//type arguments[2]:
//ENCLOSING: XXX
//Foo[225757844]
//can be singleton: TRUE
//parameter: T 99166349
//argument: T 99166349
//parent: Object [@pragma pragma(String name, [Object? options])]
//parent: Pluggable []
//CONFIG
//config: m1.Foo {stringField: FooField, integerField: 124}
//config: m1.FooChild {stringField: FooChildField, doubleField: 0.55, booleanField: true}
//config: m1.FooChild2 {stringField: FooChild2Field, doubleField: 0.55, booleanField: true}
//config: m1.Bar {stringField: BarField}
//config: m1.BarChild {stringField: BarChildField}
//config: m2.Foo {stringField2: FooStringField2}
//config: VirtualTypeX {extends: m1.SimpleGeneric<m1.Foo>, stringField: FooStringField2}
//config: m1.SimpleGeneric<m2.Foo> 1
//TYPE PATH:
//   m1.SimpleGeneric<m2.Foo>
//parametrized type
class $m1_SimpleGeneric_m2_Foo_ extends $m1_SimpleGeneric<$m2_Foo>
    implements Pluggable {
  $m1_SimpleGeneric() {}
  T plugin<T>() {
    throw new Exception('no plugin for this type');
  }
//NO ELEMENT!
}

// **************************************************************************
// All Types:
//AnnotatedWith AnnotatedWith
//Pluggable Pluggable
//TypePlugin TypePlugin
//m1.Foo m1.Foo
//m1.FooChild m1.FooChild
//m1.FooChild2 m1.FooChild2
//m1.Bar m1.Bar
//m1.BarChild m1.BarChild
//m1.SimpleGeneric m1.SimpleGeneric
//m2.Foo m2.Foo
//m2.ComplexGeneric m2.ComplexGeneric
//m2.SuperComplexGeneric m2.SuperComplexGeneric
//Container Container
//String String
//int int
//double double
//bool bool
//List<String> List<String>
//m1.T m1.T
//m1.SimpleGeneric<m1.T> m1.SimpleGeneric<m1.T>
//void void
//m2.A m2.A
//m2.B m2.B
//m2.ComplexGeneric<m2.A,m2.B> m2.ComplexGeneric<m2.A,m2.B>
//m2.SuperComplexGeneric<m2.A,m2.B> m2.SuperComplexGeneric<m2.A,m2.B>
//m2.ComplexGeneric<m2.Foo,m2.A> m2.ComplexGeneric<m2.Foo,m2.A>
//m1.SimpleGeneric<m1.Foo> m1.SimpleGeneric<m1.Foo>
//m1.SimpleGeneric<m2.Foo> m1.SimpleGeneric<m2.Foo>
// **************************************************************************
class $ObjectManager {
  $m1_Foo? _m1_Foo;
  $m1_Foo get m1_Foo {
    if (_m1_Foo == null) {
      _m1_Foo = new $m1_Foo();
    }
    return _m1_Foo as $m1_Foo;
  }

  $m1_FooChild? _m1_FooChild;
  $m1_FooChild get m1_FooChild {
    if (_m1_FooChild == null) {
      _m1_FooChild = new $m1_FooChild();
    }
    return _m1_FooChild as $m1_FooChild;
  }

  $m1_Bar? _m1_Bar;
  $m1_Bar get m1_Bar {
    if (_m1_Bar == null) {
      _m1_Bar = new $m1_Bar();
    }
    return _m1_Bar as $m1_Bar;
  }

  $m1_BarChild? _m1_BarChild;
  $m1_BarChild get m1_BarChild {
    if (_m1_BarChild == null) {
      _m1_BarChild = new $m1_BarChild();
    }
    return _m1_BarChild as $m1_BarChild;
  }

  $m1_SimpleGeneric? _m1_SimpleGeneric;
  $m1_SimpleGeneric get m1_SimpleGeneric {
    if (_m1_SimpleGeneric == null) {
      _m1_SimpleGeneric = new $m1_SimpleGeneric();
    }
    return _m1_SimpleGeneric as $m1_SimpleGeneric;
  }

  $m2_Foo? _m2_Foo;
  $m2_Foo get m2_Foo {
    if (_m2_Foo == null) {
      _m2_Foo = new $m2_Foo();
    }
    return _m2_Foo as $m2_Foo;
  }

  $m2_ComplexGeneric? _m2_ComplexGeneric;
  $m2_ComplexGeneric get m2_ComplexGeneric {
    if (_m2_ComplexGeneric == null) {
      _m2_ComplexGeneric = new $m2_ComplexGeneric();
    }
    return _m2_ComplexGeneric as $m2_ComplexGeneric;
  }

  $m2_SuperComplexGeneric? _m2_SuperComplexGeneric;
  $m2_SuperComplexGeneric get m2_SuperComplexGeneric {
    if (_m2_SuperComplexGeneric == null) {
      _m2_SuperComplexGeneric = new $m2_SuperComplexGeneric();
    }
    return _m2_SuperComplexGeneric as $m2_SuperComplexGeneric;
  }

  $m1_SimpleGeneric_m1_Foo_? _m1_SimpleGeneric_m1_Foo_;
  $m1_SimpleGeneric_m1_Foo_ get m1_SimpleGeneric_m1_Foo_ {
    if (_m1_SimpleGeneric_m1_Foo_ == null) {
      _m1_SimpleGeneric_m1_Foo_ = new $m1_SimpleGeneric_m1_Foo_();
    }
    return _m1_SimpleGeneric_m1_Foo_ as $m1_SimpleGeneric_m1_Foo_;
  }

  $m1_SimpleGeneric_m2_Foo_? _m1_SimpleGeneric_m2_Foo_;
  $m1_SimpleGeneric_m2_Foo_ get m1_SimpleGeneric_m2_Foo_ {
    if (_m1_SimpleGeneric_m2_Foo_ == null) {
      _m1_SimpleGeneric_m2_Foo_ = new $m1_SimpleGeneric_m2_Foo_();
    }
    return _m1_SimpleGeneric_m2_Foo_ as $m1_SimpleGeneric_m2_Foo_;
  }
}

$ObjectManager $om = new $ObjectManager();
//generated in 32ms
