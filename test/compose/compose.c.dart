// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'compose.dart';

// **************************************************************************
// SwiftGenerator
// **************************************************************************

// **************************************************************************
// generated by swift_composer at 2021-11-26 14:19:23.458794
//loading config file /home/fsw/workspace/swift_composer/test/lib/module1.di.yaml
//loading config file /home/fsw/workspace/swift_composer/test/lib/module2.di.yaml
// **************************************************************************
// import package:swift_composer/swift_composer.dart
// import asset:swift_composer/test/lib/module1.dart as m1
// import asset:swift_composer/test/lib/module2.dart
// **************************************************************************
//no interceptor for [AnnotatedWith]
// **************************************************************************
//no interceptor for [Pluggable]
// **************************************************************************
//no interceptor for [TypePlugin]
// **************************************************************************
//interceptor for [m1.Foo]
//type arguments[1]:
//type arguments[2]:
//can be singleton: TRUE
//parent: Object [@pragma pragma(String name, [Object? options])]
//parent: Pluggable []
//CONFIG
//config: m1.Foo {stringField: FooField, integerField: 124}
//config: m1.FooChild {stringField: FooChildField, doubleField: 0.55, booleanField: true}
//config: m1.FooChild2 {stringField: FooChild2Field, doubleField: 0.55, booleanField: true}
//config: m1.Bar {stringField: BarField}
//config: m1.BarChild {stringField: BarChildField}
//config: Foo {stringField2: FooStringField2}
//config: m1.Foo 1
//config: stringField FooField
//config: integerField 124
//TYPE PATH:
//   m1.Foo
class $m1_Foo extends m1.Foo implements Pluggable {
  $m1_Foo() {}
  T plugin<T>() {
    throw new Exception('no plugin for this type');
  }

  String get className => "m1.Foo";
  String get stringField => "FooField";
  int get integerField => 124;
}

// **************************************************************************
//interceptor for [m1.FooChild]
//type arguments[1]:
//type arguments[2]:
//can be singleton: TRUE
//parent: Foo [@bool get Compose]
//parent: Object [@pragma pragma(String name, [Object? options])]
//parent: Pluggable []
//CONFIG
//config: m1.Foo {stringField: FooField, integerField: 124}
//config: m1.FooChild {stringField: FooChildField, doubleField: 0.55, booleanField: true}
//config: m1.FooChild2 {stringField: FooChild2Field, doubleField: 0.55, booleanField: true}
//config: m1.Bar {stringField: BarField}
//config: m1.BarChild {stringField: BarChildField}
//config: Foo {stringField2: FooStringField2}
//config: m1.FooChild 1
//config: stringField FooChildField
//config: doubleField 0.55
//config: booleanField true
//config: m1.Foo 2
//config: integerField 124
//TYPE PATH:
//   m1.FooChild
//   m1.Foo
class $m1_FooChild extends m1.FooChild implements Pluggable {
  $m1_FooChild() {}
  T plugin<T>() {
    throw new Exception('no plugin for this type');
  }

  double get doubleField => 0.55;
  bool get booleanField => true;
  String get className => "m1.FooChild";
  String get stringField => "FooChildField";
  int get integerField => 124;
}

// **************************************************************************
//interceptor for [m1.FooChild2]
//type arguments[1]:
//type arguments[2]:
//can be singleton: FALSE
//parent: Foo [@bool get Compose]
//parent: Object [@pragma pragma(String name, [Object? options])]
//parent: Pluggable []
//CONFIG
//config: m1.Foo {stringField: FooField, integerField: 124}
//config: m1.FooChild {stringField: FooChildField, doubleField: 0.55, booleanField: true}
//config: m1.FooChild2 {stringField: FooChild2Field, doubleField: 0.55, booleanField: true}
//config: m1.Bar {stringField: BarField}
//config: m1.BarChild {stringField: BarChildField}
//config: Foo {stringField2: FooStringField2}
//config: m1.FooChild2 1
//config: stringField FooChild2Field
//config: doubleField 0.55
//config: booleanField true
//config: m1.Foo 2
//config: integerField 124
//TYPE PATH:
//   m1.FooChild2
//   m1.Foo
class $m1_FooChild2 extends m1.FooChild2 implements Pluggable {
  $m1_FooChild2(requiredString) {
//String
    this.requiredString = requiredString;
  }
  T plugin<T>() {
    throw new Exception('no plugin for this type');
  }

  String get className => "m1.FooChild2";
  String get stringField => "FooChild2Field";
  int get integerField => 124;
}

// **************************************************************************
//interceptor for [m1.Bar]
//type arguments[1]:
//type arguments[2]:
//can be singleton: TRUE
//parent: Object [@pragma pragma(String name, [Object? options])]
//CONFIG
//config: m1.Foo {stringField: FooField, integerField: 124}
//config: m1.FooChild {stringField: FooChildField, doubleField: 0.55, booleanField: true}
//config: m1.FooChild2 {stringField: FooChild2Field, doubleField: 0.55, booleanField: true}
//config: m1.Bar {stringField: BarField}
//config: m1.BarChild {stringField: BarChildField}
//config: Foo {stringField2: FooStringField2}
//config: m1.Bar 1
//config: stringField BarField
//TYPE PATH:
//   m1.Bar
class $m1_Bar extends m1.Bar implements Pluggable {
  $m1_Bar() {}
  T plugin<T>() {
    throw new Exception('no plugin for this type');
  }

  String get stringField => "BarField";
  List<String> get classNames => [];
}

// **************************************************************************
//interceptor for [m1.BarChild]
//type arguments[1]:
//type arguments[2]:
//can be singleton: TRUE
//parent: Bar [@bool get Compose]
//parent: Object [@pragma pragma(String name, [Object? options])]
//CONFIG
//config: m1.Foo {stringField: FooField, integerField: 124}
//config: m1.FooChild {stringField: FooChildField, doubleField: 0.55, booleanField: true}
//config: m1.FooChild2 {stringField: FooChild2Field, doubleField: 0.55, booleanField: true}
//config: m1.Bar {stringField: BarField}
//config: m1.BarChild {stringField: BarChildField}
//config: Foo {stringField2: FooStringField2}
//config: m1.BarChild 1
//config: stringField BarChildField
//config: m1.Bar 2
//TYPE PATH:
//   m1.BarChild
//   m1.Bar
class $m1_BarChild extends m1.BarChild implements Pluggable {
  $m1_BarChild() {}
  T plugin<T>() {
    throw new Exception('no plugin for this type');
  }

  String get stringField => "BarChildField";
  List<String> get classNames => ['m1.BarChild'];
}

// **************************************************************************
//interceptor for [m1.SimpleGeneric]
//type arguments[1]:
//T[402361370] => T[402361370]
//type arguments[2]:
//can be singleton: TRUE
//parameter: T 402361370
//argument: T 402361370
//parent: Object [@pragma pragma(String name, [Object? options])]
//parent: Pluggable []
//CONFIG
//config: m1.Foo {stringField: FooField, integerField: 124}
//config: m1.FooChild {stringField: FooChildField, doubleField: 0.55, booleanField: true}
//config: m1.FooChild2 {stringField: FooChild2Field, doubleField: 0.55, booleanField: true}
//config: m1.Bar {stringField: BarField}
//config: m1.BarChild {stringField: BarChildField}
//config: Foo {stringField2: FooStringField2}
//NO ELEMENT!
//config: m1.SimpleGeneric<m1.T> 1
//TYPE PATH:
//NO ELEMENT!
//   m1.SimpleGeneric<m1.T>
class $m1_SimpleGeneric<T> extends m1.SimpleGeneric<T> implements Pluggable {
  $m1_SimpleGeneric() {}
  T plugin<T>() {
    throw new Exception('no plugin for this type');
  }
//NO ELEMENT!
}

// **************************************************************************
//interceptor for [Foo]
//type arguments[1]:
//type arguments[2]:
//can be singleton: TRUE
//parent: Object [@pragma pragma(String name, [Object? options])]
//CONFIG
//config: m1.Foo {stringField: FooField, integerField: 124}
//config: m1.FooChild {stringField: FooChildField, doubleField: 0.55, booleanField: true}
//config: m1.FooChild2 {stringField: FooChild2Field, doubleField: 0.55, booleanField: true}
//config: m1.Bar {stringField: BarField}
//config: m1.BarChild {stringField: BarChildField}
//config: Foo {stringField2: FooStringField2}
//config: Foo 1
//config: stringField2 FooStringField2
//TYPE PATH:
//   Foo
class $Foo extends Foo implements Pluggable {
  $Foo() {}
  T plugin<T>() {
    throw new Exception('no plugin for this type');
  }

  String get className => "Foo";
  String get stringField2 => "FooStringField2";
}

// **************************************************************************
//interceptor for [ComplexGeneric]
//type arguments[1]:
//A[162257751] => A[162257751]
//B[247988282] => B[247988282]
//type arguments[2]:
//can be singleton: TRUE
//parameter: A 162257751
//parameter: B 247988282
//argument: A 162257751
//argument: B 247988282
//parent: Object [@pragma pragma(String name, [Object? options])]
//CONFIG
//config: m1.Foo {stringField: FooField, integerField: 124}
//config: m1.FooChild {stringField: FooChildField, doubleField: 0.55, booleanField: true}
//config: m1.FooChild2 {stringField: FooChild2Field, doubleField: 0.55, booleanField: true}
//config: m1.Bar {stringField: BarField}
//config: m1.BarChild {stringField: BarChildField}
//config: Foo {stringField2: FooStringField2}
//NO ELEMENT!
//NO ELEMENT!
//config: ComplexGeneric<A,B> 1
//TYPE PATH:
//NO ELEMENT!
//NO ELEMENT!
//   ComplexGeneric<A,B>
class $ComplexGeneric<A, B> extends ComplexGeneric<A, B> implements Pluggable {
  $ComplexGeneric() {}
  T plugin<T>() {
    throw new Exception('no plugin for this type');
  }
//NO ELEMENT!
}

// **************************************************************************
//interceptor for [SuperComplexGeneric]
//type arguments[1]:
//A[162257751] => Foo[214916430]
//B[247988282] => A[17451649]
//A[17451649] => A[17451649]
//B[436879447] => B[436879447]
//type arguments[2]:
//can be singleton: TRUE
//parameter: A 17451649
//parameter: B 436879447
//argument: A 17451649
//argument: B 436879447
//parent: ComplexGeneric [@bool get Compose]
//parameter: A 162257751
//parameter: B 247988282
//argument: Foo 214916430
//argument: A 17451649
//parent: Object [@pragma pragma(String name, [Object? options])]
//CONFIG
//config: m1.Foo {stringField: FooField, integerField: 124}
//config: m1.FooChild {stringField: FooChildField, doubleField: 0.55, booleanField: true}
//config: m1.FooChild2 {stringField: FooChild2Field, doubleField: 0.55, booleanField: true}
//config: m1.Bar {stringField: BarField}
//config: m1.BarChild {stringField: BarChildField}
//config: Foo {stringField2: FooStringField2}
//NO ELEMENT!
//NO ELEMENT!
//NO ELEMENT!
//config: SuperComplexGeneric<A,B> 1
//config: ComplexGeneric<Foo,A> 2
//TYPE PATH:
//NO ELEMENT!
//NO ELEMENT!
//   SuperComplexGeneric<A,B>
//NO ELEMENT!
//   ComplexGeneric<Foo,A>
class $SuperComplexGeneric<A, B> extends SuperComplexGeneric<A, B>
    implements Pluggable {
  $SuperComplexGeneric() {}
  T plugin<T>() {
    throw new Exception('no plugin for this type');
  }
//NO ELEMENT!
//NO ELEMENT!
}

// **************************************************************************
//interceptor for [Container]
//type arguments[1]:
//type arguments[2]:
//can be singleton: FALSE
//parent: Object [@pragma pragma(String name, [Object? options])]
//CONFIG
//config: m1.Foo {stringField: FooField, integerField: 124}
//config: m1.FooChild {stringField: FooChildField, doubleField: 0.55, booleanField: true}
//config: m1.FooChild2 {stringField: FooChild2Field, doubleField: 0.55, booleanField: true}
//config: m1.Bar {stringField: BarField}
//config: m1.BarChild {stringField: BarChildField}
//config: Foo {stringField2: FooStringField2}
//config: Container 1
//TYPE PATH:
//   Container
class $Container extends Container implements Pluggable {
  $Container(fooRequired, genericRequired) {
//Foo
//create
//candidate: AnnotatedWith
//element ok
//name not fit
//interceptor ok
//candidate: Pluggable
//element ok
//name not fit
//candidate: TypePlugin
//element ok
//candidate: m1.Foo
//element ok
//candidate: m1.FooChild
//element ok
//name not fit
//interceptor ok
//candidate: m1.FooChild2
//element ok
//name not fit
//interceptor ok
//candidate: m1.Bar
//element ok
//name not fit
//interceptor ok
//candidate: m1.BarChild
//element ok
//name not fit
//interceptor ok
//candidate: m1.SimpleGeneric
//element ok
//name not fit
//interceptor ok
//candidate: Foo
//element ok
//name not fit
//interceptor ok
//candidate: ComplexGeneric
//element ok
//name not fit
//interceptor ok
//candidate: SuperComplexGeneric
//element ok
//name not fit
//interceptor ok
//candidate: Container
//element ok
//name not fit
//interceptor ok
//candidate: AbstractGeneric
//element ok
//name not fit
//candidate: GenericInterface
//element ok
//name not fit
//candidate: GenericTypedWithFoo
//element ok
//name not fit
//interceptor ok
//candidate: GenericContainer
//element ok
//name not fit
//candidate: ContainerFoo
//element ok
//name not fit
//interceptor ok
//candidate: String
//element ok
//name not fit
//candidate: int
//element ok
//name not fit
//candidate: double
//element ok
//name not fit
//candidate: bool
//element ok
//name not fit
//interceptor ok
//candidate: List<String>
//element ok
//name not fit
//candidate: m1.T
//candidate: m1.SimpleGeneric<m1.T>
//element ok
//name not fit
//candidate: void
//candidate: A
//candidate: B
//candidate: ComplexGeneric<A,B>
//element ok
//name not fit
//candidate: SuperComplexGeneric<A,B>
//element ok
//name not fit
//candidate: ComplexGeneric<Foo,A>
//element ok
//name not fit
    this.fooCreated = new $m1_Foo();
//SimpleGeneric<Foo>
//create
//candidate: AnnotatedWith
//element ok
//name not fit
//interceptor ok
//candidate: Pluggable
//element ok
//name not fit
//candidate: TypePlugin
//element ok
//candidate: m1.Foo
//element ok
//name not fit
//interceptor ok
//candidate: m1.FooChild
//element ok
//name not fit
//interceptor ok
//candidate: m1.FooChild2
//element ok
//name not fit
//interceptor ok
//candidate: m1.Bar
//element ok
//name not fit
//interceptor ok
//candidate: m1.BarChild
//element ok
//name not fit
//interceptor ok
//candidate: m1.SimpleGeneric
//element ok
//name not fit
//interceptor ok
//candidate: Foo
//element ok
//name not fit
//interceptor ok
//candidate: ComplexGeneric
//element ok
//name not fit
//interceptor ok
//candidate: SuperComplexGeneric
//element ok
//name not fit
//interceptor ok
//candidate: Container
//element ok
//name not fit
//interceptor ok
//candidate: AbstractGeneric
//element ok
//name not fit
//candidate: GenericInterface
//element ok
//name not fit
//candidate: GenericTypedWithFoo
//element ok
//name not fit
//interceptor ok
//candidate: GenericContainer
//element ok
//name not fit
//candidate: ContainerFoo
//element ok
//name not fit
//interceptor ok
//candidate: String
//element ok
//name not fit
//candidate: int
//element ok
//name not fit
//candidate: double
//element ok
//name not fit
//candidate: bool
//element ok
//name not fit
//interceptor ok
//candidate: List<String>
//element ok
//name not fit
//candidate: m1.T
//candidate: m1.SimpleGeneric<m1.T>
//element ok
//name not fit
//candidate: void
//candidate: A
//candidate: B
//candidate: ComplexGeneric<A,B>
//element ok
//name not fit
//candidate: SuperComplexGeneric<A,B>
//element ok
//name not fit
//candidate: ComplexGeneric<Foo,A>
//element ok
//name not fit
//candidate: m1.SimpleGeneric<m1.Foo>
//element ok
    this.genericCreated = new $m1_SimpleGeneric_m1_Foo_();
//Foo
    this.fooRequired = fooRequired;
//SimpleGeneric<Foo>
    this.genericRequired = genericRequired;
  }
  T plugin<T>() {
    throw new Exception('no plugin for this type');
  }

//candidate: AnnotatedWith
//element ok
//name not fit
//interceptor ok
//candidate: Pluggable
//element ok
//name not fit
//candidate: TypePlugin
//element ok
//candidate: m1.Foo
//element ok
//candidate: m1.FooChild
//element ok
//name not fit
//interceptor ok
//candidate: m1.FooChild2
//element ok
//name not fit
//interceptor ok
//candidate: m1.Bar
//element ok
//name not fit
//interceptor ok
//candidate: m1.BarChild
//element ok
//name not fit
//interceptor ok
//candidate: m1.SimpleGeneric
//element ok
//name not fit
//interceptor ok
//candidate: Foo
//element ok
//name not fit
//interceptor ok
//candidate: ComplexGeneric
//element ok
//name not fit
//interceptor ok
//candidate: SuperComplexGeneric
//element ok
//name not fit
//interceptor ok
//candidate: Container
//element ok
//name not fit
//interceptor ok
//candidate: AbstractGeneric
//element ok
//name not fit
//candidate: GenericInterface
//element ok
//name not fit
//candidate: GenericTypedWithFoo
//element ok
//name not fit
//interceptor ok
//candidate: GenericContainer
//element ok
//name not fit
//candidate: ContainerFoo
//element ok
//name not fit
//interceptor ok
//candidate: String
//element ok
//name not fit
//candidate: int
//element ok
//name not fit
//candidate: double
//element ok
//name not fit
//candidate: bool
//element ok
//name not fit
//interceptor ok
//candidate: List<String>
//element ok
//name not fit
//candidate: m1.T
//candidate: m1.SimpleGeneric<m1.T>
//element ok
//name not fit
//candidate: void
//candidate: A
//candidate: B
//candidate: ComplexGeneric<A,B>
//element ok
//name not fit
//candidate: SuperComplexGeneric<A,B>
//element ok
//name not fit
//candidate: ComplexGeneric<Foo,A>
//element ok
//name not fit
//candidate: m1.SimpleGeneric<m1.Foo>
//element ok
//name not fit
//interceptor ok
//candidate: m1.SimpleGeneric<Foo>
//element ok
//name not fit
//interceptor ok
  m1.Foo get fooInjected => $om.m1_Foo;
//candidate: AnnotatedWith
//element ok
//name not fit
//interceptor ok
//candidate: Pluggable
//element ok
//name not fit
//candidate: TypePlugin
//element ok
//candidate: m1.Foo
//element ok
//name not fit
//interceptor ok
//candidate: m1.FooChild
//element ok
//name not fit
//interceptor ok
//candidate: m1.FooChild2
//element ok
//name not fit
//interceptor ok
//candidate: m1.Bar
//element ok
//name not fit
//interceptor ok
//candidate: m1.BarChild
//element ok
//name not fit
//interceptor ok
//candidate: m1.SimpleGeneric
//element ok
//name not fit
//interceptor ok
//candidate: Foo
//element ok
//name not fit
//interceptor ok
//candidate: ComplexGeneric
//element ok
//name not fit
//interceptor ok
//candidate: SuperComplexGeneric
//element ok
//name not fit
//interceptor ok
//candidate: Container
//element ok
//name not fit
//interceptor ok
//candidate: AbstractGeneric
//element ok
//name not fit
//candidate: GenericInterface
//element ok
//name not fit
//candidate: GenericTypedWithFoo
//element ok
//name not fit
//interceptor ok
//candidate: GenericContainer
//element ok
//name not fit
//candidate: ContainerFoo
//element ok
//name not fit
//interceptor ok
//candidate: String
//element ok
//name not fit
//candidate: int
//element ok
//name not fit
//candidate: double
//element ok
//name not fit
//candidate: bool
//element ok
//name not fit
//interceptor ok
//candidate: List<String>
//element ok
//name not fit
//candidate: m1.T
//candidate: m1.SimpleGeneric<m1.T>
//element ok
//name not fit
//candidate: void
//candidate: A
//candidate: B
//candidate: ComplexGeneric<A,B>
//element ok
//name not fit
//candidate: SuperComplexGeneric<A,B>
//element ok
//name not fit
//candidate: ComplexGeneric<Foo,A>
//element ok
//name not fit
//candidate: m1.SimpleGeneric<m1.Foo>
//element ok
//candidate: m1.SimpleGeneric<Foo>
//element ok
//name not fit
//interceptor ok
  m1.SimpleGeneric<m1.Foo> get genericInjected => $om.m1_SimpleGeneric_m1_Foo_;
}

// **************************************************************************
//no interceptor for [AbstractGeneric]
// **************************************************************************
//no interceptor for [GenericInterface]
// **************************************************************************
//interceptor for [GenericTypedWithFoo]
//type arguments[1]:
//T[166216658] => Foo[467258976]
//K[281078034] => Foo[467258976]
//type arguments[2]:
//can be singleton: TRUE
//parent: AbstractGeneric []
//parameter: T 166216658
//argument: Foo 467258976
//parent: Object [@pragma pragma(String name, [Object? options])]
//parent: GenericInterface []
//parameter: K 281078034
//argument: Foo 467258976
//CONFIG
//config: m1.Foo {stringField: FooField, integerField: 124}
//config: m1.FooChild {stringField: FooChildField, doubleField: 0.55, booleanField: true}
//config: m1.FooChild2 {stringField: FooChild2Field, doubleField: 0.55, booleanField: true}
//config: m1.Bar {stringField: BarField}
//config: m1.BarChild {stringField: BarChildField}
//config: Foo {stringField2: FooStringField2}
//config: GenericTypedWithFoo 1
//config: AbstractGeneric<m1.Foo> 2
//TYPE PATH:
//   GenericTypedWithFoo
//   AbstractGeneric<m1.Foo>
class $GenericTypedWithFoo extends GenericTypedWithFoo implements Pluggable {
  $GenericTypedWithFoo() {}
  T plugin<T>() {
    throw new Exception('no plugin for this type');
  }

//candidate: AnnotatedWith
//element ok
//name not fit
//interceptor ok
//candidate: Pluggable
//element ok
//name not fit
//candidate: TypePlugin
//element ok
//candidate: m1.Foo
//element ok
//candidate: m1.FooChild
//element ok
//name not fit
//interceptor ok
//candidate: m1.FooChild2
//element ok
//name not fit
//interceptor ok
//candidate: m1.Bar
//element ok
//name not fit
//interceptor ok
//candidate: m1.BarChild
//element ok
//name not fit
//interceptor ok
//candidate: m1.SimpleGeneric
//element ok
//name not fit
//interceptor ok
//candidate: Foo
//element ok
//name not fit
//interceptor ok
//candidate: ComplexGeneric
//element ok
//name not fit
//interceptor ok
//candidate: SuperComplexGeneric
//element ok
//name not fit
//interceptor ok
//candidate: Container
//element ok
//name not fit
//interceptor ok
//candidate: AbstractGeneric
//element ok
//name not fit
//candidate: GenericInterface
//element ok
//name not fit
//candidate: GenericTypedWithFoo
//element ok
//name not fit
//interceptor ok
//candidate: GenericContainer
//element ok
//name not fit
//candidate: ContainerFoo
//element ok
//name not fit
//interceptor ok
//candidate: String
//element ok
//name not fit
//candidate: int
//element ok
//name not fit
//candidate: double
//element ok
//name not fit
//candidate: bool
//element ok
//name not fit
//interceptor ok
//candidate: List<String>
//element ok
//name not fit
//candidate: m1.T
//candidate: m1.SimpleGeneric<m1.T>
//element ok
//name not fit
//candidate: void
//candidate: A
//candidate: B
//candidate: ComplexGeneric<A,B>
//element ok
//name not fit
//candidate: SuperComplexGeneric<A,B>
//element ok
//name not fit
//candidate: ComplexGeneric<Foo,A>
//element ok
//name not fit
//candidate: m1.SimpleGeneric<m1.Foo>
//element ok
//name not fit
//interceptor ok
//candidate: m1.SimpleGeneric<Foo>
//element ok
//name not fit
//interceptor ok
//candidate: AbstractGeneric<m1.Foo>
//element ok
//name not fit
  m1.Foo get element => $om.m1_Foo;
//candidate: AnnotatedWith
//element ok
//name not fit
//interceptor ok
//candidate: Pluggable
//element ok
//name not fit
//candidate: TypePlugin
//element ok
//candidate: m1.Foo
//element ok
//name not fit
//interceptor ok
//candidate: m1.FooChild
//element ok
//name not fit
//interceptor ok
//candidate: m1.FooChild2
//element ok
//name not fit
//interceptor ok
//candidate: m1.Bar
//element ok
//name not fit
//interceptor ok
//candidate: m1.BarChild
//element ok
//name not fit
//interceptor ok
//candidate: m1.SimpleGeneric
//element ok
//name not fit
//interceptor ok
//candidate: Foo
//element ok
//name not fit
//interceptor ok
//candidate: ComplexGeneric
//element ok
//name not fit
//interceptor ok
//candidate: SuperComplexGeneric
//element ok
//name not fit
//interceptor ok
//candidate: Container
//element ok
//name not fit
//interceptor ok
//candidate: AbstractGeneric
//element ok
//name not fit
//candidate: GenericInterface
//element ok
//name not fit
//candidate: GenericTypedWithFoo
//element ok
//name not fit
//interceptor ok
//candidate: GenericContainer
//element ok
//name not fit
//candidate: ContainerFoo
//element ok
//name not fit
//interceptor ok
//candidate: String
//element ok
//name not fit
//candidate: int
//element ok
//name not fit
//candidate: double
//element ok
//name not fit
//candidate: bool
//element ok
//name not fit
//interceptor ok
//candidate: List<String>
//element ok
//name not fit
//candidate: m1.T
//candidate: m1.SimpleGeneric<m1.T>
//element ok
//name not fit
//candidate: void
//candidate: A
//candidate: B
//candidate: ComplexGeneric<A,B>
//element ok
//name not fit
//candidate: SuperComplexGeneric<A,B>
//element ok
//name not fit
//candidate: ComplexGeneric<Foo,A>
//element ok
//name not fit
//candidate: m1.SimpleGeneric<m1.Foo>
//element ok
//candidate: m1.SimpleGeneric<Foo>
//element ok
//name not fit
//interceptor ok
//candidate: AbstractGeneric<m1.Foo>
//element ok
//name not fit
  m1.SimpleGeneric<m1.Foo> get generic => $om.m1_SimpleGeneric_m1_Foo_;
}

// **************************************************************************
//no interceptor for [GenericContainer]
// **************************************************************************
//interceptor for [ContainerFoo]
//type arguments[1]:
//T[134552618] => Foo[467258976]
//type arguments[2]:
//can be singleton: TRUE
//parent: GenericContainer []
//parameter: T 134552618
//argument: Foo 467258976
//parent: Object [@pragma pragma(String name, [Object? options])]
//CONFIG
//config: m1.Foo {stringField: FooField, integerField: 124}
//config: m1.FooChild {stringField: FooChildField, doubleField: 0.55, booleanField: true}
//config: m1.FooChild2 {stringField: FooChild2Field, doubleField: 0.55, booleanField: true}
//config: m1.Bar {stringField: BarField}
//config: m1.BarChild {stringField: BarChildField}
//config: Foo {stringField2: FooStringField2}
//config: ContainerFoo 1
//config: GenericContainer<m1.Foo> 2
//TYPE PATH:
//   ContainerFoo
//   GenericContainer<m1.Foo>
class $ContainerFoo extends ContainerFoo implements Pluggable {
  $ContainerFoo() {
//AbstractGeneric<T>
//create
//candidate: AnnotatedWith
//element ok
//name not fit
//interceptor ok
//candidate: Pluggable
//element ok
//name not fit
//candidate: TypePlugin
//element ok
//candidate: m1.Foo
//element ok
//name not fit
//interceptor ok
//candidate: m1.FooChild
//element ok
//name not fit
//interceptor ok
//candidate: m1.FooChild2
//element ok
//name not fit
//interceptor ok
//candidate: m1.Bar
//element ok
//name not fit
//interceptor ok
//candidate: m1.BarChild
//element ok
//name not fit
//interceptor ok
//candidate: m1.SimpleGeneric
//element ok
//name not fit
//interceptor ok
//candidate: Foo
//element ok
//name not fit
//interceptor ok
//candidate: ComplexGeneric
//element ok
//name not fit
//interceptor ok
//candidate: SuperComplexGeneric
//element ok
//name not fit
//interceptor ok
//candidate: Container
//element ok
//name not fit
//interceptor ok
//candidate: AbstractGeneric
//element ok
//name not fit
//candidate: GenericInterface
//element ok
//name not fit
//candidate: GenericTypedWithFoo
//element ok
//name not fit
//interceptor ok
//candidate: GenericContainer
//element ok
//name not fit
//candidate: ContainerFoo
//element ok
//name not fit
//interceptor ok
//candidate: String
//element ok
//name not fit
//candidate: int
//element ok
//name not fit
//candidate: double
//element ok
//name not fit
//candidate: bool
//element ok
//name not fit
//interceptor ok
//candidate: List<String>
//element ok
//name not fit
//candidate: m1.T
//candidate: m1.SimpleGeneric<m1.T>
//element ok
//name not fit
//candidate: void
//candidate: A
//candidate: B
//candidate: ComplexGeneric<A,B>
//element ok
//name not fit
//candidate: SuperComplexGeneric<A,B>
//element ok
//name not fit
//candidate: ComplexGeneric<Foo,A>
//element ok
//name not fit
//candidate: m1.SimpleGeneric<m1.Foo>
//element ok
//name not fit
//interceptor ok
//candidate: m1.SimpleGeneric<Foo>
//element ok
//name not fit
//interceptor ok
//candidate: AbstractGeneric<m1.Foo>
//element ok
//candidate: GenericContainer<m1.Foo>
//element ok
//name not fit
    this.genericFoo = new $GenericTypedWithFoo();
//GenericInterface<T>
//create
//candidate: AnnotatedWith
//element ok
//name not fit
//interceptor ok
//candidate: Pluggable
//element ok
//name not fit
//candidate: TypePlugin
//element ok
//candidate: m1.Foo
//element ok
//name not fit
//interceptor ok
//candidate: m1.FooChild
//element ok
//name not fit
//interceptor ok
//candidate: m1.FooChild2
//element ok
//name not fit
//interceptor ok
//candidate: m1.Bar
//element ok
//name not fit
//interceptor ok
//candidate: m1.BarChild
//element ok
//name not fit
//interceptor ok
//candidate: m1.SimpleGeneric
//element ok
//name not fit
//interceptor ok
//candidate: Foo
//element ok
//name not fit
//interceptor ok
//candidate: ComplexGeneric
//element ok
//name not fit
//interceptor ok
//candidate: SuperComplexGeneric
//element ok
//name not fit
//interceptor ok
//candidate: Container
//element ok
//name not fit
//interceptor ok
//candidate: AbstractGeneric
//element ok
//name not fit
//candidate: GenericInterface
//element ok
//name not fit
//candidate: GenericTypedWithFoo
//element ok
//name not fit
//interceptor ok
//candidate: GenericContainer
//element ok
//name not fit
//candidate: ContainerFoo
//element ok
//name not fit
//interceptor ok
//candidate: String
//element ok
//name not fit
//candidate: int
//element ok
//name not fit
//candidate: double
//element ok
//name not fit
//candidate: bool
//element ok
//name not fit
//interceptor ok
//candidate: List<String>
//element ok
//name not fit
//candidate: m1.T
//candidate: m1.SimpleGeneric<m1.T>
//element ok
//name not fit
//candidate: void
//candidate: A
//candidate: B
//candidate: ComplexGeneric<A,B>
//element ok
//name not fit
//candidate: SuperComplexGeneric<A,B>
//element ok
//name not fit
//candidate: ComplexGeneric<Foo,A>
//element ok
//name not fit
//candidate: m1.SimpleGeneric<m1.Foo>
//element ok
//name not fit
//interceptor ok
//candidate: m1.SimpleGeneric<Foo>
//element ok
//name not fit
//interceptor ok
//candidate: AbstractGeneric<m1.Foo>
//element ok
//name not fit
//candidate: GenericContainer<m1.Foo>
//element ok
//name not fit
//candidate: GenericInterface<m1.Foo>
//element ok
    this.genericInterface = new $GenericTypedWithFoo();
//T
//create
//candidate: AnnotatedWith
//element ok
//name not fit
//interceptor ok
//candidate: Pluggable
//element ok
//name not fit
//candidate: TypePlugin
//element ok
//candidate: m1.Foo
//element ok
//candidate: m1.FooChild
//element ok
//name not fit
//interceptor ok
//candidate: m1.FooChild2
//element ok
//name not fit
//interceptor ok
//candidate: m1.Bar
//element ok
//name not fit
//interceptor ok
//candidate: m1.BarChild
//element ok
//name not fit
//interceptor ok
//candidate: m1.SimpleGeneric
//element ok
//name not fit
//interceptor ok
//candidate: Foo
//element ok
//name not fit
//interceptor ok
//candidate: ComplexGeneric
//element ok
//name not fit
//interceptor ok
//candidate: SuperComplexGeneric
//element ok
//name not fit
//interceptor ok
//candidate: Container
//element ok
//name not fit
//interceptor ok
//candidate: AbstractGeneric
//element ok
//name not fit
//candidate: GenericInterface
//element ok
//name not fit
//candidate: GenericTypedWithFoo
//element ok
//name not fit
//interceptor ok
//candidate: GenericContainer
//element ok
//name not fit
//candidate: ContainerFoo
//element ok
//name not fit
//interceptor ok
//candidate: String
//element ok
//name not fit
//candidate: int
//element ok
//name not fit
//candidate: double
//element ok
//name not fit
//candidate: bool
//element ok
//name not fit
//interceptor ok
//candidate: List<String>
//element ok
//name not fit
//candidate: m1.T
//candidate: m1.SimpleGeneric<m1.T>
//element ok
//name not fit
//candidate: void
//candidate: A
//candidate: B
//candidate: ComplexGeneric<A,B>
//element ok
//name not fit
//candidate: SuperComplexGeneric<A,B>
//element ok
//name not fit
//candidate: ComplexGeneric<Foo,A>
//element ok
//name not fit
//candidate: m1.SimpleGeneric<m1.Foo>
//element ok
//name not fit
//interceptor ok
//candidate: m1.SimpleGeneric<Foo>
//element ok
//name not fit
//interceptor ok
//candidate: AbstractGeneric<m1.Foo>
//element ok
//name not fit
//candidate: GenericContainer<m1.Foo>
//element ok
//name not fit
//candidate: GenericInterface<m1.Foo>
//element ok
//name not fit
    this.child = new $m1_Foo();
  }
  T plugin<T>() {
    throw new Exception('no plugin for this type');
  }
}

// **************************************************************************
//no interceptor for [String]
// **************************************************************************
//no interceptor for [int]
// **************************************************************************
//no interceptor for [double]
// **************************************************************************
//no interceptor for [bool]
// **************************************************************************
//no interceptor for [List<String>]
// **************************************************************************
//no interceptor for [m1.T]
// **************************************************************************
//no interceptor for [m1.SimpleGeneric<m1.T>]
// **************************************************************************
//no interceptor for [void]
// **************************************************************************
//no interceptor for [A]
// **************************************************************************
//no interceptor for [B]
// **************************************************************************
//no interceptor for [ComplexGeneric<A,B>]
// **************************************************************************
//no interceptor for [SuperComplexGeneric<A,B>]
// **************************************************************************
//no interceptor for [ComplexGeneric<Foo,A>]
// **************************************************************************
//interceptor for [m1.SimpleGeneric<m1.Foo>]
//type arguments[1]:
//T[402361370] => Foo[467258976]
//type arguments[2]:
//ENCLOSING: XXX
//Foo[844475758]
//can be singleton: TRUE
//parameter: T 402361370
//argument: T 402361370
//parent: Object [@pragma pragma(String name, [Object? options])]
//parent: Pluggable []
//CONFIG
//config: m1.Foo {stringField: FooField, integerField: 124}
//config: m1.FooChild {stringField: FooChildField, doubleField: 0.55, booleanField: true}
//config: m1.FooChild2 {stringField: FooChild2Field, doubleField: 0.55, booleanField: true}
//config: m1.Bar {stringField: BarField}
//config: m1.BarChild {stringField: BarChildField}
//config: Foo {stringField2: FooStringField2}
//config: m1.SimpleGeneric<m1.Foo> 1
//TYPE PATH:
//   m1.SimpleGeneric<m1.Foo>
//parametrized type
class $m1_SimpleGeneric_m1_Foo_ extends $m1_SimpleGeneric<$m1_Foo>
    implements Pluggable {
  $m1_SimpleGeneric() {}
  T plugin<T>() {
    throw new Exception('no plugin for this type');
  }
//NO ELEMENT!
}

// **************************************************************************
//interceptor for [m1.SimpleGeneric<Foo>]
//type arguments[1]:
//T[402361370] => Foo[214916430]
//type arguments[2]:
//ENCLOSING: XXX
//Foo[1059386144]
//can be singleton: TRUE
//parameter: T 402361370
//argument: T 402361370
//parent: Object [@pragma pragma(String name, [Object? options])]
//parent: Pluggable []
//CONFIG
//config: m1.Foo {stringField: FooField, integerField: 124}
//config: m1.FooChild {stringField: FooChildField, doubleField: 0.55, booleanField: true}
//config: m1.FooChild2 {stringField: FooChild2Field, doubleField: 0.55, booleanField: true}
//config: m1.Bar {stringField: BarField}
//config: m1.BarChild {stringField: BarChildField}
//config: Foo {stringField2: FooStringField2}
//config: m1.SimpleGeneric<Foo> 1
//TYPE PATH:
//   m1.SimpleGeneric<Foo>
//parametrized type
class $m1_SimpleGeneric_Foo_ extends $m1_SimpleGeneric<$Foo>
    implements Pluggable {
  $m1_SimpleGeneric() {}
  T plugin<T>() {
    throw new Exception('no plugin for this type');
  }
//NO ELEMENT!
}

// **************************************************************************
//no interceptor for [AbstractGeneric<m1.Foo>]
// **************************************************************************
//no interceptor for [GenericContainer<m1.Foo>]
// **************************************************************************
//no interceptor for [GenericInterface<m1.Foo>]
// **************************************************************************
// All Types:
//AnnotatedWith AnnotatedWith
//Pluggable Pluggable
//TypePlugin TypePlugin
//m1.Foo m1.Foo
//m1.FooChild m1.FooChild
//m1.FooChild2 m1.FooChild2
//m1.Bar m1.Bar
//m1.BarChild m1.BarChild
//m1.SimpleGeneric m1.SimpleGeneric
//Foo Foo
//ComplexGeneric ComplexGeneric
//SuperComplexGeneric SuperComplexGeneric
//Container Container
//AbstractGeneric AbstractGeneric
//GenericInterface GenericInterface
//GenericTypedWithFoo GenericTypedWithFoo
//GenericContainer GenericContainer
//ContainerFoo ContainerFoo
//String String
//int int
//double double
//bool bool
//List<String> List<String>
//m1.T m1.T
//m1.SimpleGeneric<m1.T> m1.SimpleGeneric<m1.T>
//void void
//A A
//B B
//ComplexGeneric<A,B> ComplexGeneric<A,B>
//SuperComplexGeneric<A,B> SuperComplexGeneric<A,B>
//ComplexGeneric<Foo,A> ComplexGeneric<Foo,A>
//m1.SimpleGeneric<m1.Foo> m1.SimpleGeneric<m1.Foo>
//m1.SimpleGeneric<Foo> m1.SimpleGeneric<Foo>
//AbstractGeneric<m1.Foo> AbstractGeneric<m1.Foo>
//GenericContainer<m1.Foo> GenericContainer<m1.Foo>
//GenericInterface<m1.Foo> GenericInterface<m1.Foo>
// **************************************************************************
class $ObjectManager {
  $m1_Foo? _m1_Foo;
  $m1_Foo get m1_Foo {
    if (_m1_Foo == null) {
      _m1_Foo = new $m1_Foo();
    }
    return _m1_Foo as $m1_Foo;
  }

  $m1_FooChild? _m1_FooChild;
  $m1_FooChild get m1_FooChild {
    if (_m1_FooChild == null) {
      _m1_FooChild = new $m1_FooChild();
    }
    return _m1_FooChild as $m1_FooChild;
  }

  $m1_Bar? _m1_Bar;
  $m1_Bar get m1_Bar {
    if (_m1_Bar == null) {
      _m1_Bar = new $m1_Bar();
    }
    return _m1_Bar as $m1_Bar;
  }

  $m1_BarChild? _m1_BarChild;
  $m1_BarChild get m1_BarChild {
    if (_m1_BarChild == null) {
      _m1_BarChild = new $m1_BarChild();
    }
    return _m1_BarChild as $m1_BarChild;
  }

  $m1_SimpleGeneric? _m1_SimpleGeneric;
  $m1_SimpleGeneric get m1_SimpleGeneric {
    if (_m1_SimpleGeneric == null) {
      _m1_SimpleGeneric = new $m1_SimpleGeneric();
    }
    return _m1_SimpleGeneric as $m1_SimpleGeneric;
  }

  $Foo? _foo;
  $Foo get foo {
    if (_foo == null) {
      _foo = new $Foo();
    }
    return _foo as $Foo;
  }

  $ComplexGeneric? _complexGeneric;
  $ComplexGeneric get complexGeneric {
    if (_complexGeneric == null) {
      _complexGeneric = new $ComplexGeneric();
    }
    return _complexGeneric as $ComplexGeneric;
  }

  $SuperComplexGeneric? _superComplexGeneric;
  $SuperComplexGeneric get superComplexGeneric {
    if (_superComplexGeneric == null) {
      _superComplexGeneric = new $SuperComplexGeneric();
    }
    return _superComplexGeneric as $SuperComplexGeneric;
  }

  $GenericTypedWithFoo? _genericTypedWithFoo;
  $GenericTypedWithFoo get genericTypedWithFoo {
    if (_genericTypedWithFoo == null) {
      _genericTypedWithFoo = new $GenericTypedWithFoo();
    }
    return _genericTypedWithFoo as $GenericTypedWithFoo;
  }

  $ContainerFoo? _containerFoo;
  $ContainerFoo get containerFoo {
    if (_containerFoo == null) {
      _containerFoo = new $ContainerFoo();
    }
    return _containerFoo as $ContainerFoo;
  }

  $m1_SimpleGeneric_m1_Foo_? _m1_SimpleGeneric_m1_Foo_;
  $m1_SimpleGeneric_m1_Foo_ get m1_SimpleGeneric_m1_Foo_ {
    if (_m1_SimpleGeneric_m1_Foo_ == null) {
      _m1_SimpleGeneric_m1_Foo_ = new $m1_SimpleGeneric_m1_Foo_();
    }
    return _m1_SimpleGeneric_m1_Foo_ as $m1_SimpleGeneric_m1_Foo_;
  }

  $m1_SimpleGeneric_Foo_? _m1_SimpleGeneric_Foo_;
  $m1_SimpleGeneric_Foo_ get m1_SimpleGeneric_Foo_ {
    if (_m1_SimpleGeneric_Foo_ == null) {
      _m1_SimpleGeneric_Foo_ = new $m1_SimpleGeneric_Foo_();
    }
    return _m1_SimpleGeneric_Foo_ as $m1_SimpleGeneric_Foo_;
  }
}

$ObjectManager $om = new $ObjectManager();
//generated in 15ms
